use crate::ast::{AstNode, Parameter, Statement, TraitMethod, Type, VariantDecl};
use crate::lexer::tokenize_with_locations;
use crate::parser::parse_with_locations;

pub fn generate_markdown(input_file: &str, source_code: &str) -> Result<String, String> {
    let tokens = tokenize_with_locations(source_code, Some(input_file.to_string()));
    let ast = parse_with_locations(tokens).map_err(|err| format!("Parse error: {}", err))?;

    let mut modules = Vec::new();
    let mut functions = Vec::new();
    let mut structs = Vec::new();
    let mut enums = Vec::new();
    let mut traits = Vec::new();

    for node in ast {
        if let AstNode::Statement(stmt) = node {
            match stmt {
                Statement::ModDecl { name, is_public } => {
                    let vis = if is_public { "pub " } else { "" };
                    modules.push(format!("`{}mod {}`", vis, name));
                }
                Statement::Function {
                    name,
                    parameters,
                    return_type,
                    type_params,
                    trait_bounds,
                    ..
                } => {
                    let signature =
                        format_function_signature(&name, &parameters, &return_type, &type_params);
                    let bounds = format_trait_bounds(&trait_bounds);
                    functions.push((signature, bounds));
                }
                Statement::StructDef {
                    name,
                    fields,
                    type_params,
                } => {
                    structs.push((name, fields, type_params));
                }
                Statement::EnumDef {
                    name,
                    variants,
                    type_params,
                } => {
                    enums.push((name, variants, type_params));
                }
                Statement::TraitDef {
                    name,
                    type_params,
                    methods,
                } => {
                    traits.push((name, type_params, methods));
                }
                _ => {}
            }
        }
    }

    let mut out = String::new();
    out.push_str("# Aero API Documentation\n\n");
    out.push_str(&format!(
        "Generated by `aero doc` for `{}`.\n\n",
        input_file
    ));

    if modules.is_empty() {
        out.push_str("## Modules\n\n_No module declarations found._\n\n");
    } else {
        out.push_str("## Modules\n\n");
        for module in modules {
            out.push_str(&format!("- {}\n", module));
        }
        out.push('\n');
    }

    if functions.is_empty() {
        out.push_str("## Functions\n\n_No function declarations found._\n\n");
    } else {
        out.push_str("## Functions\n\n");
        for (signature, bounds) in functions {
            out.push_str(&format!("### `{}`\n\n", signature));
            if !bounds.is_empty() {
                out.push_str("Trait bounds:\n\n");
                for line in bounds {
                    out.push_str(&format!("- `{}`\n", line));
                }
                out.push('\n');
            }
        }
    }

    if structs.is_empty() {
        out.push_str("## Structs\n\n_No struct declarations found._\n\n");
    } else {
        out.push_str("## Structs\n\n");
        for (name, fields, type_params) in structs {
            out.push_str(&format!(
                "### `{}`\n\n",
                format_named_type(&name, &type_params)
            ));
            if fields.is_empty() {
                out.push_str("_No fields._\n\n");
            } else {
                out.push_str("Fields:\n\n");
                for field in fields {
                    out.push_str(&format!(
                        "- `{}`: `{}`\n",
                        field.name,
                        format_type(&field.field_type)
                    ));
                }
                out.push('\n');
            }
        }
    }

    if enums.is_empty() {
        out.push_str("## Enums\n\n_No enum declarations found._\n\n");
    } else {
        out.push_str("## Enums\n\n");
        for (name, variants, type_params) in enums {
            out.push_str(&format!(
                "### `{}`\n\n",
                format_named_type(&name, &type_params)
            ));
            if variants.is_empty() {
                out.push_str("_No variants._\n\n");
            } else {
                out.push_str("Variants:\n\n");
                for variant in variants {
                    out.push_str(&format!("- `{}`\n", format_variant(&variant)));
                }
                out.push('\n');
            }
        }
    }

    if traits.is_empty() {
        out.push_str("## Traits\n\n_No trait declarations found._\n");
    } else {
        out.push_str("## Traits\n\n");
        for (name, type_params, methods) in traits {
            out.push_str(&format!(
                "### `{}`\n\n",
                format_named_type(&name, &type_params)
            ));
            if methods.is_empty() {
                out.push_str("_No methods._\n\n");
            } else {
                out.push_str("Methods:\n\n");
                for method in methods {
                    out.push_str(&format!("- `{}`\n", format_trait_method(&method)));
                }
                out.push('\n');
            }
        }
    }

    Ok(out)
}

fn format_function_signature(
    name: &str,
    parameters: &[Parameter],
    return_type: &Option<Type>,
    type_params: &[String],
) -> String {
    let type_suffix = if type_params.is_empty() {
        String::new()
    } else {
        format!("<{}>", type_params.join(", "))
    };

    let params = parameters
        .iter()
        .map(|p| format!("{}: {}", p.name, format_type(&p.param_type)))
        .collect::<Vec<_>>()
        .join(", ");

    let ret = match return_type {
        Some(ty) => format!(" -> {}", format_type(ty)),
        None => String::new(),
    };

    format!("fn {}{}({}){}", name, type_suffix, params, ret)
}

fn format_trait_bounds(bounds: &[(String, Vec<String>)]) -> Vec<String> {
    bounds
        .iter()
        .map(|(type_param, constraints)| format!("{}: {}", type_param, constraints.join(" + ")))
        .collect()
}

fn format_trait_method(method: &TraitMethod) -> String {
    let params = method
        .parameters
        .iter()
        .map(|p| format!("{}: {}", p.name, format_type(&p.param_type)))
        .collect::<Vec<_>>()
        .join(", ");
    let ret = method
        .return_type
        .as_ref()
        .map_or(String::new(), |ty| format!(" -> {}", format_type(ty)));
    format!("fn {}({}){}", method.name, params, ret)
}

fn format_named_type(name: &str, type_params: &[String]) -> String {
    if type_params.is_empty() {
        name.to_string()
    } else {
        format!("{}<{}>", name, type_params.join(", "))
    }
}

fn format_variant(variant: &VariantDecl) -> String {
    use crate::ast::VariantDeclKind;

    match &variant.kind {
        VariantDeclKind::Unit => variant.name.clone(),
        VariantDeclKind::Tuple(types) => {
            let values = types.iter().map(format_type).collect::<Vec<_>>().join(", ");
            format!("{}({})", variant.name, values)
        }
        VariantDeclKind::Struct(fields) => {
            let fields_str = fields
                .iter()
                .map(|f| format!("{}: {}", f.name, format_type(&f.field_type)))
                .collect::<Vec<_>>()
                .join(", ");
            format!("{} {{ {} }}", variant.name, fields_str)
        }
    }
}

fn format_type(ty: &Type) -> String {
    match ty {
        Type::Named(name) => name.clone(),
        Type::Array(inner, size) => format!("[{}; {}]", format_type(inner), size),
        Type::Tuple(items) => {
            let inner = items.iter().map(format_type).collect::<Vec<_>>().join(", ");
            format!("({})", inner)
        }
        Type::Reference(inner, mutable) => {
            if *mutable {
                format!("&mut {}", format_type(inner))
            } else {
                format!("&{}", format_type(inner))
            }
        }
        Type::Generic(name, args) => {
            let rendered_args = args.iter().map(format_type).collect::<Vec<_>>().join(", ");
            format!("{}<{}>", name, rendered_args)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generates_markdown_for_core_declarations() {
        let source = r#"
mod math;

struct Vec2 {
    x: int,
    y: int,
}

enum Color {
    Red,
    Rgb(int, int, int),
}

trait Draw {
    fn draw(self);
}

fn add<T>(x: int, y: int) -> int where T: Draw {
    return x + y;
}
"#;

        let doc = generate_markdown("main.aero", source).expect("doc generation should succeed");
        assert!(doc.contains("# Aero API Documentation"));
        assert!(doc.contains("## Modules"));
        assert!(doc.contains("`mod math`"));
        assert!(doc.contains("## Structs"));
        assert!(doc.contains("### `Vec2`"));
        assert!(doc.contains("## Enums"));
        assert!(doc.contains("### `Color`"));
        assert!(doc.contains("## Traits"));
        assert!(doc.contains("### `Draw`"));
        assert!(doc.contains("## Functions"));
        assert!(doc.contains("### `fn add<T>(x: int, y: int) -> int`"));
        assert!(doc.contains("`T: Draw`"));
    }

    #[test]
    fn handles_empty_program() {
        let doc = generate_markdown("empty.aero", "").expect("doc generation should succeed");
        assert!(doc.contains("No function declarations found"));
        assert!(doc.contains("No struct declarations found"));
        assert!(doc.contains("No enum declarations found"));
        assert!(doc.contains("No trait declarations found"));
    }
}
